package ImageTools

import (
	"fmt"
	"image"
	"math"
	"reflect"
	"runtime"
	"sync"
)

var defaultCurve = []float32{
	0.00000, 0.02576, 0.05148, 0.07712, 0.10264, 0.12799, 0.15313, 0.17803, 0.20264, 0.22692, 0.25083, 0.27432, 0.29737, 0.31991, 0.34193, 0.36336,
	0.38418, 0.40433, 0.42379, 0.44250, 0.46043, 0.47754, 0.49378, 0.50911, 0.52350, 0.53690, 0.54926, 0.56055, 0.57073, 0.57976, 0.58984, 0.59659,
	0.60321, 0.60969, 0.61604, 0.62226, 0.62835, 0.63432, 0.64016, 0.64588, 0.65147, 0.65694, 0.66230, 0.66754, 0.67267, 0.67768, 0.68258, 0.68738,
	0.69206, 0.69664, 0.70112, 0.70549, 0.70976, 0.71394, 0.71802, 0.72200, 0.72589, 0.72968, 0.73339, 0.73701, 0.74055, 0.74399, 0.74736, 0.75065,
	0.75385, 0.75698, 0.76003, 0.76301, 0.76592, 0.76875, 0.77152, 0.77422, 0.77686, 0.77943, 0.78194, 0.78439, 0.78679, 0.78912, 0.79140, 0.79363,
	0.79581, 0.79794, 0.80002, 0.80206, 0.80405, 0.80600, 0.80791, 0.80978, 0.81162, 0.81342, 0.81518, 0.81692, 0.81862, 0.82030, 0.82195, 0.82358,
	0.82518, 0.82676, 0.82833, 0.82987, 0.83140, 0.83292, 0.83442, 0.83592, 0.83740, 0.83888, 0.84036, 0.84183, 0.84329, 0.84476, 0.84623, 0.84771,
	0.84919, 0.85068, 0.85217, 0.85368, 0.85520, 0.85674, 0.85829, 0.85986, 0.86145, 0.86306, 0.86469, 0.86635, 0.86803, 0.86974, 0.87149, 0.87326,
	0.87500, 0.87681, 0.87861, 0.88038, 0.88214, 0.88388, 0.88560, 0.88730, 0.88898, 0.89064, 0.89228, 0.89391, 0.89552, 0.89711, 0.89868, 0.90023,
	0.90177, 0.90329, 0.90479, 0.90627, 0.90774, 0.90919, 0.91063, 0.91205, 0.91345, 0.91483, 0.91620, 0.91756, 0.91890, 0.92022, 0.92153, 0.92282,
	0.92410, 0.92536, 0.92661, 0.92784, 0.92906, 0.93027, 0.93146, 0.93263, 0.93380, 0.93495, 0.93608, 0.93720, 0.93831, 0.93941, 0.94050, 0.94157,
	0.94263, 0.94367, 0.94471, 0.94573, 0.94674, 0.94774, 0.94872, 0.94970, 0.95066, 0.95162, 0.95256, 0.95349, 0.95441, 0.95532, 0.95622, 0.95711,
	0.95799, 0.95886, 0.95973, 0.96058, 0.96142, 0.96225, 0.96307, 0.96389, 0.96469, 0.96549, 0.96628, 0.96706, 0.96783, 0.96860, 0.96936, 0.97010,
	0.97085, 0.97158, 0.97231, 0.97303, 0.97374, 0.97445, 0.97515, 0.97584, 0.97653, 0.97721, 0.97789, 0.97856, 0.97922, 0.97988, 0.98053, 0.98118,
	0.98182, 0.98246, 0.98309, 0.98372, 0.98435, 0.98497, 0.98559, 0.98620, 0.98681, 0.98741, 0.98802, 0.98862, 0.98921, 0.98980, 0.99039, 0.99098,
	0.99157, 0.99215, 0.99273, 0.99331, 0.99389, 0.99446, 0.99503, 0.99561, 0.99618, 0.99675, 0.99732, 0.99788, 0.99845, 0.99902, 0.99959, 1.000000,
}

type CurveManipulator struct {
	cLut []byte
}

func MakeDefaultCurveManipulator() *CurveManipulator {
	_, cm := MakeCurveManipulator(defaultCurve)
	return cm
}

func MakeCurveManipulator(curve []float32) (error, *CurveManipulator) {
	if len(curve) != 256 {
		return fmt.Errorf("invalid curve size: %d. Expected 256", len(curve)), nil
	}

	cLut := make([]byte, 256)
	for i := 0; i < 256; i++ {
		cLut[i] = byte(math.Floor(float64(curve[i]) * 255))
	}

	return nil, &CurveManipulator{
		cLut: cLut,
	}
}

func (cm *CurveManipulator) ApplyCurve(img image.Image) error {
	switch v := img.(type) {
	case *image.RGBA:
		return cm.applyCurveRGBA(v)
	case *image.Gray:
		return cm.applyCurveGray(v)
	default:
		return fmt.Errorf("unsupported image type: %s", reflect.TypeOf(img).Name())
	}
}

func (cm *CurveManipulator) applyCurveGray(img *image.Gray) error {
	cm.applyCurveParallel(img.Pix)
	return nil
}

func (cm *CurveManipulator) applyCurveRGBA(img *image.RGBA) error {
	cm.applyCurveParallel(img.Pix)
	return nil
}

func (cm *CurveManipulator) applyCurveParallel(data []byte) {
	wg := sync.WaitGroup{}
	n := runtime.NumCPU()
	t := len(data)
	w := t / n

	for i := 0; i < n; i++ {
		s := i * w
		e := (i + 1) * w
		if i+1 == n {
			e = len(data)
		}

		chunk := data[s:e]
		wg.Add(1)
		go func() {
			for i := 0; i < len(chunk); i++ {
				chunk[i] = cm.cLut[chunk[i]]
			}
			wg.Done()
		}()
	}

	wg.Wait()
}
